
"A string is an immutable sequence of bytes."

When you run `len(string)` this will return the number of bytes not the number of characters. You can access the byte of a string by running `string[i]` where `i` is `0 <= i < len(s)`.

If you have this variable: `var s = "hello"` and you run `s[0]` you will get `h`. If you try and run `s[10]` you will get a compiler error saying index out of range.

If you run `s[0:3]` you will get `hel`, if you do `s[0:5]` you will get `hello`. If you omit a number, the default is 0. Thus, `s[0:3]` is the same as `s[:3]`.

You can also add strings:

```go
func main() {
	var s = "hello"
	var a = "world"

	fmt.Println(s + " " + a)
}
```

This will print:

```txt
hello world
```

Since strings are immutable, you can not run this code:

```go
func main() {
	var s = "hello"
	s[0] = "L" // cannot assign to s[0] (neither addressable nor a map index expression)
}
```

### 3.5.1 String Literals

A string literal is just this: `var s = "Hello World!"` - a sequence of bytes enclosed in double quotes.

You can also add escape sequences into string literals:

- `\a` alert
- `\b` backspace
- `\f` form feed
- `\n` newline
- `\r` carriage return
- `\t` tab
- `\v` vertical tab
- `\'` single quote
- `\"` double quote
- `\\` backslash

So this code:

```go
func main() {
	var s = "hello"
	var a = "world"
	fmt.Printf("\"%s\"\t\\\\\t\"%s\"\n", s, a)
}
```

Will output:

```txt
"hello" \\      "world"
```

There are also raw string literals:

```go
func main() {
	const Gousage = `Go is a tool for managing Go source code.
	
	Usage:
		go command [arguments]\n\t\r`

	fmt.Println(Gousage)
}
```

No escape sequences work in raw string literals, the content inside of the backtick quotes will be taken as literally, thus printing out:

```txt
Go is a tool for managing Go source code.

    Usage:
           go command [arguments]\n\t\r
```

### 3.5.2 Unicode

ASCII stands for the American Standard Code for Information Interchange which used 7 bits to represent 128 characters. This worked for the English language but fell apart once the world adopted the internet and lots of other languages we're involved with computers.

Unicode was the solution, which holds over 120,000 characters in over 100 languages. To hold a single rune you use `int32`. But, that is a lot of space for each character.

### 3.5.3 UTF-8

UTF-8 uses only 1 byte for an ASCII character (a.k.a English character) and if its a rune outside of the English language UTF-8 will use 2-3 bytes. UTF-8 allows you to use ASCII for standard English but not have to make your strings be too big.

Go source files are encoded in UTF-8.

The book then goes in depth on encoding/decoding UTF-8, which I do not particularly care for. I will rarely if ever do this since I speak English.

### 3.5.4 Strings and Byte Slices

Four important Go packages for strings: `bytes`, `strings`, `strconv`, and `unicode`.

`strings` helps with searching, replacing, comparing, trimming, splitting, and joining strings.
`bytes` helps with manipulating slices of bytes, which helps a lot since strings are immutable.
`strconv` helps with converting Boolean, integer, and floating-point numbers to and from their string representation.
`unicode` helps with classifying runes: `IsDigit`, `IsLetter`, `IsUpper`, and `IsLower`, which take in a rune and return a Boolean value. There's also `ToUpper` and `ToLower`.
	Important: The `strings` package also has a `ToUpper` and `ToLower` function but those functions return a `new string` which you may not want.

Here is an example using the `strings` package to remove file name extensions:

```go
package main

import (
	"strings"
	"fmt"
)

func main() {
	fmt.Println(basename("a/b/c.go"))
	fmt.Println(basename("c.d.go"))
	fmt.Println(basename("abc"))
}

func basename(s string) string {
	slash := strings.LastIndex(s, "/")
	s = s[slash+1:]
	if dot := strings.LastIndex(s, "."); dot >= 0 {
		s = s[:dot]
	}
	return s
}
```

This will print:

```txt
c
c.d
abc
```

Then here's a code example that will turn "12345" into "12,345":

```go
func main() {
	fmt.Println(comma("12345"))
	fmt.Println(comma("999999999"))
	fmt.Println(comma("82311230812"))
}

func comma(s string) string {
	n := len(s)
	if n <= 3 {
		return s
	}
	return comma(s[:n-3]) + "," + s[n-3:]
}
```

This will print:

```txt
12,345
999,999,999
82,311,230,812
```

Strings are immutable but you can convert them to a byte slice which can be changed:

```go
func main() {
	s := "abc"
	b := []byte(s)
	b[0] = byte('z')
	s2 := string(b)
	fmt.Println(s2)
}
```

This will output:

```txt
zbc
```

This is inefficient as when you create `b := []byte(s)` you are now allocating extra memory to create a copy of the bytes of string `s`. It's best to use `Buffer` in the `bytes` package for effective byte manipulation:

```go
func main() {
	fmt.Println(intsToString([]int{1,2,3}))
}

func intsToString(values []int) string {
	var buf bytes.Buffer
	buf.WriteByte('[')
	for i, v := range values {
		if i > 0 {
			buf.WriteString(", ")
		}
		fmt.Fprintf(&buf, "%d", v)
	}
	buf.WriteByte(']')
	return buf.String()
}
```

This will print out:

```txt
[1, 2, 3]
```