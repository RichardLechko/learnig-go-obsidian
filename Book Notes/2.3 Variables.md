## Variable Declarations

When you use [[Var|var]] you declare a variable of a particular type, attach a name to it, and set it's initial value.

### Syntax

```go
var name type = expression
```
You can remove the `type` or the `= expression` but not both at the same time.

- if type is removed -> compiler determines type based on expression
- if the expression is removed -> initial value is set to  [[Zero Value|zero value]] of that type

### Zero Values

- Numbers -> `0`
- Booleans -> `false`
- Strings -> `""`
- [[Interfaces]] and [[Reference Types]] -> `nil`

**Important:** No such thing as an uninitialized variable in Go.

## Example of Variable Declaration

```go
var i, j, k int                 // int, int, and int
var b, f, s = true, 2.3, "four" // bool, float64, and string
```

## Time of Initialization
Variables get initialized at different times depending on where they are.

- [[Package-Level|Package-level]] variables -> initialized before [[Main Function|main]] begins
- [[Local]] variables -> initialized as their declarations are encountered during runtime

## 2.3.1 Short Variable Declarations

You can initialized variables using a short-form method in Go

```go
i := 100 // int
```

**Best Practice:** Use short variable declarations majority of the time. Use [[Var|var]] for local variables that need an explicit type that differs from that of the initializer expression:

```go
i := 100                  //int
var boiling float64 = 100 // float64
```

You can declare multiple variables:
```go
i, j := 0, 1
```

## Import Distinction

- `:=` is a **declaration**
- `=` is an **assignment**

### Redeclaration Rules

With short variable declarations, if any variables on the left-hand side were already declared, they get assigned instead of redeclared:

```go
in, err := os.Open(infile)
// ... do something
out, err := os.Create(outfile)
```

First statement: declares and initializes `in` and `err`. Second statement: declares `out`, but only assigns to existing `err`.

**Rule:** Short variable declaration must declare at least one new variable, so this will fail:

```go
i, j := 1
// ...
i, j := 2 // compile error
```

## Swapping Values

```go
i, j = j, i // swap values of i and j
```

## 2.3.2 Pointers

"A variable is a piece of storage containing a value."

"A pointer value is the address of a variable." Pointer holds location of a variable, not every value has an address, but every variable does.

### Syntax

```go
x := 1           // x is equal to 1
p := &x          // p, of type *int, points to the memory address of x
fmt.Println(*p)  // "1"
*p = 2           // equivalent to x = 2
fmt.Println(x)   // "2"
```

### Zero Value

The [[Zero Value}zero value]] of any pointer is `nil`.

- `p != nil` if true, `p` points to a `variable`
- Pointers can only equal one another if they point to the same variable in memory.

## Using Pointers in Functions

You can pass pointers as parameter arguments:

```go
func main() {
    v := 1                 // v = 1
    incr(&v)               // we pass the memory address of v to the incr func()
    fmt.Println(incr(&v))  // "3" and v is 3.
}

func incr(p *int) int {
    *p++;      // this increments the value that p is pointing to by 1
    return *p; // return this incremented value
}
```

## 2.3.3 The `new` Function

You can also declare variables with [[New Function|new]].

`new(T)` creates an unnamed variable of type T, gets initialized to the zero value of type T, and returns its address (value of type *T):

```go
p := new(int)   // p, of type *int, points to the unnamed int variable
fmt.Println(*p) // "0"
*p = 2          // sets the unnamed int to 2
fmt.Println(*p) // "2"
```

### Equivalent Code

These two blocks have the same behavior:

```go
func newInt() *int {
	return new(int)
}
```

and

```go
func newInt() *int {
	var dummy int
	return &dummy
}
```

**Important:** Every time you use [[New Function|new]] to declare a variable you get a different memory address.

## 2.3.4 Lifetime of Variables

The lifetime of a variable is how long it "live" in a program:

- [[Package-Level|Package-level]] variable -> entire execution of the program
- [[Local]] variable -> dynamic lifetime, new instance is created each time declaration statement is executed, lives until it becomes unreachable.

### For Loop Example

```go
for i := 0; i < 10; i++ {
	fmt.Println(i)
}
```

Variable `i` is created each time the [[For Loops|for loop]] begins. Local variables inside the loop are also created on each iteration.

**Key Principle:** "The lifetime of a variable is determined only by whether or not it is reachable"

### Variable Outliving Loop

A local variable can outlive a single iteration:

```go
i := 0
for i = 0; i < 10; i++ {  }
fmt.Println(i) // prints 10, i is still alive
```

## Stack vs Heap Allocation

A compiler decides if local variables on the [[Stack|stack]] or the [[Heap|heap]]. Sometimes you can use [[New Function|new]] or [[Var|var]] to influence where they get allocated:

### Heap-Allocated (var)
```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}
```

Variable `x` must be **`heap-allocated`** because it's reachable even after the function `f` returns. The `global` variable holds `x`'s memory address, so `x` is still reachable.

We say that `x` escapes from `f`.

### Stack-Allocated (new)
```go
func g() {
    y := new(int)
    *y = 1
}
```

When function `g` returns, we can no longer reach the variable `*y`, so it can be recycled. Thus, `*y` gets allocated on the stack.

We say that `*y` does **not** escape from `g`.

### Why This Matters

- Each variable that escapes requires an extra memory allocation.
- Multiple unnecessary pointers holding addresses of short-lived objects prevent Go's [[Garbage Collector|garbage collector]] from doing its job.

## Related Conepts
- [[Pointers]]
- [[Zero Value]]
- [[Stack]]
- [[Heap]]
- [[Scope]]