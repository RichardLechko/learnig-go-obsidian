Lots of ways to store a number in Go, the type you use to represent a number will determine the size and signedness of it.

There are 10 different types of integer types:

```go
// Signed Numbers
int8
int16
int32
int64

// Unsigned Numbers
uint8
uint16
uint32
uint64

// Generic Integers (Most Efficient)
int
uint
```

`int` is used by far the most.

There is also the type `rune` which stands for `int32` but more importantly hints to the compiler that the value is a Unicode code point. There's also `byte` which stands for `int8` and hints to the compiler that the value is a piece of raw data, not just a small number.

There is also `uintptr` which has no specified width but can hold all the bits of a pointer value. `uintptr` is mostly used in low-level programming.

Even though the natural size of `int` may be 32 bits, you still can not directly compare `int` to `int32` without an explicit type conversion.

Signed numbers are represented in 2's complement form.

Signed Integers Range: -2^n-1 to 2^n-1 - 1.
Unsigned Integers Range: 0 to 2^n - 1.

To represent a negative number, you take the highest ordered bit to use as the negative symbol.

These are the binary operators for arithmetic, logic, and comparison listed in order of decreasing precedence, there are 5 categories:

1. `*` `/` `%` `<<` `>>` `&` `&^`
2.  `+` `-` `|` `^`
3.  `==` `!=` `<` `<=` `>` `>=`
4.  `&&`
5.  `||`

If you have a condition that has operators on the same level, sometimes you need to use parenthesis for better clarity, like:

```go
mask & ( 1 << 28)
```

Each operator in the first two categories has a corresponding assignment operator to abbreviate an assignment statement, like `+=`, `*=`, etc.

These are the integer arithmetic operators: `+`, `-`, `*`, and `/`. You can use these on integers, floating-point, and complex numbers, and you can only use `%` on integers.

When you use `%` on negative numbers, the remainder maintains the same sign as the dividend:

```go
-5 % 3  // -2
-5 % -3 // -2
```

If you divide integers, the result gets truncated, so:

```go
5 / 4 // 1
```

If you have `uint8` variable, which can hold a numeric value from 0 to 255, set the value to 255, then add 1, that'll cause an `overflow` and go back to 0:

```go
func main() {
	var u uint8 = 255
	fmt.Println(u, u+1, u*u)

	var i int8 = 127
	fmt.Println(i, i+1, i*i)
}
```

You will get this output:

```txt
255 0 1
127 -128 1
```

All values of basic types, which are Booleans, numbers, and strings, are comparable, meaning you can use `==` and `!=` on them.

There are some short hands as well for integers:

- `+x` is `0 + x`
- `-x` is `0 - x`

Then for floating point:

- `+x` is `x`
- `-x` is the negation of `x`

There are also bitwise binary operators:

- `&` bitwise AND
- `|` bitwise OR
- `^` bitwise XOR
	- when used as a binary operator it's a bitwise exclusive operator
	- when used as a unary prefix operator it's a bitwise negation (all bits get flipped)
- `&^` bit clear (AND NOT)
	- In this expression `z = x &^ y` each bit of `z` is 0 if the bit in `y` is 1, if `y` is not 1 then use the bit in `x`.
- `<<` left shift
- `>>` right shift

Code Example of bitwise operators:

```go
func main() {
	var x uint8 = 1 << 1 | 1 << 5
	var y uint8 = 1 << 1 | 1 << 2

	fmt.Printf("%08b\n", x)
	fmt.Printf("%08b\n", y)

	fmt.Printf("%08b\n", x&y)
	fmt.Printf("%08b\n", x|y)
	fmt.Printf("%08b\n", x^y)
	fmt.Printf("%08b\n", x&^y)

	for i := uint(0); i < 8; i++ {
		if x&(1<<i) != 0 {
			fmt.Println(i)
		}
	}

	fmt.Printf("%08b\n", x<<1)
	fmt.Printf("%08b\n", x>>1)
}
```

This will print:

```txt
00100010
00000110
00000010
00100110
00100100
00100000
1
5
01000100
00010001
```

So this is the progression of `var x`:

- `var x uint8;` --> `00000000`
	- Declare an empty uint8 which is all zeros
- `var x uint8 = 1` --> `00000001`
	- Initialize the variable to hold 1, which is `00000001` in binary
- `var x uint8 = 1 << 1` --> `00000010`
	- Shift the 1 to the left by 1 position, which is `00000010` in binary
- `var x uint8 = 1 << 1 | 1 << 5` --> `00100010`
	- There are two bit shift operations that happen and then get combined by the OR operator
	- `var x uint8 = 1 << 1` --> `00000010`
	- `var x uint8 = 1 << 5` --> `00100000`
	- Now you combine these two using OR --> `00100010`

Thus, `var x uint8 = 1 << 1 | 1 << 5` will produce `00100010`

This is the progression of `var y`:

- `var y uint8;` --> `00000000`
	- Declare an empty uint8 which is all zeros
- `var y uint8 = 1` --> `00000001`
	- Initialize the variable to hold 1, which is `00000001` in binary
- `var y uint8 = 1 << 1` --> `00000010`
	- Shift the 1 to the left by 1 position, which is `00000010` in binary
- `var y uint8 = 1 << 1 | 1 << 2` -->
	- There are two bit shift operations that happen and then get combined by the OR operator
	- `var y uint8 = 1 << 1` --> `00000010`
	- `var y uint8 = 1 << 2` --> `00000100`
	- Now you combine these two using OR --> `00000110`

Thus, `var y uint8 = 1 << 1 | 1 << 5` will produce `00000110`

We are at this point now:
- `x = 00100010`
- `y = 00000110`

When you do `x & y` you are saying only include the bits where x AND y are 1. You will get `00000010`

When you do `x | y` you are saying only include the bits where x OR y are 1. You will get `00100110`

When you do `x ^ y` you are saying only include the bits where x OR y are 1 but not both at the same time. You will get `00100100`

When you do `x &^ y` you are saying you only want bits that are 1 in x but are also not in y. You will get `00100000`

Then in this for loop:

```go
for i := uint(0); i < 8; i++ {
		if x&(1<<i) != 0 {
			fmt.Println(i)
		}
	}
```

`uint(0)` is equal to `00000000`
`1 << i` is a mask of all 0's except one position is set to 1 and is position `i`

Thus, we will get:
- `1 << 0` you will get `00000001`
- `1 << 1` you will get `00000010`
- `1 << 2` you will get `00000100`
- `1 << 3` you will get `00001000`
- `1 << 4` you will get `00010000`
- `1 << 5` you will get `00100000`
- `1 << 6` you will get `01000000`
- `1 << 7` you will get `10000000`

Then when you pair that AND bitwise operator: `x & (1 << i)` this will only return true if both bits in `x` and `(1 << i)` are 1 and then return their position, so we will get back:

```txt
1
5
```

Which makes sense because we ran: `var x uint8 = 1 << 1 | 1 << 5`

Then we run `x << 1` which means shift everything to the left by 1.

So thus `00100010` becomes `01000100`

Then we run `x >> 1` which means shift everything to the right by 1.

So thus `00100010` becomes `00010001`.

