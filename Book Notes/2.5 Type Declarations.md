← Previous: [[2.4 Assignments]] | → Next: [[2.6 Packages and Files]]

## Purpose of Types

The type of a variable determines:

- Its size in memory
- How it's represented internally
- The intrinsic operations available
- The methods associated with it

## Type Declarations

A [[Type Declaration]] defines a new [[Named Types|named type]] that has the same [[Underlying Type]] as an existing type:

```go
type Celsius float64
type Fahrenheit float64
```

This creates two distinct types, both with underlying type `float64`, but they are **not interchangeable**.

## Example: Temperature Package

```go
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
    AbsoluteZeroC Celsius = -273.15
    FreezingC     Celsius = 0
    BoilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
    return Fahrenheit(c*9/5 + 32)
}

func FToC(f Fahrenheit) Celsius {
    return Celsius((f - 32) * 5/9)
}
```

## Benefits of Distinct Types

Creating distinct types helps:

- **Prevent accidents:** Can't mix temperatures with other float64 values
- **Improve clarity:** Makes code self-documenting
- **Enable methods:** Can attach methods to the new type

## Type Conversions

To convert between different types with the same underlying type, use explicit conversion:

```go
var c Celsius = 100
var f Fahrenheit = CToF(c)

// Explicit conversions required:
var temp float64 = float64(c)   // Celsius to float64
var c2 Celsius = Celsius(temp)  // float64 to Celsius
```

**Important:** "A conversion never fails at run-time."

## Comparisons with Named Types

Because Celsius and Fahrenheit have the same underlying type (float64):

- They can use all float64 arithmetic operators
- They can be compared to zero
- They **cannot** be compared to each other without conversion

```go
var c Celsius
var f Fahrenheit

fmt.Println(c == 0)          // ✓ true
fmt.Println(f >= 0)          // ✓ true
fmt.Println(c == f)          // ✗ compile error: type mismatch
fmt.Println(c == Celsius(f)) // ✓ true (after conversion)
```

## Adding Methods to Named Types

When you declare your own types, you can add [[Methods]] that give the type behaviors that don't exist by default:

```go
func (c Celsius) String() string {
    return fmt.Sprintf("%g°C", c)
}
```

This allows the type to have custom functionality beyond what the underlying type provides.

## Related Concepts

- [[Named Types]]
- [[Underlying Type]]
- [[Type Conversions]]
- [[Methods]]
- [[Type Safety]]