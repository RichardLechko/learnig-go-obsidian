
Type of variable determines size, how they are represented in memory, intrinsic operations, and the methods associated with them.

There's also `type declaration`, which declares a `new type` but this `new type` still has the same underlying type as an already existing one:

```go
package tempconv0

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
    AbsoluteZeroC Celsius = -273.15
    FreezingC     Celsius = 0
    BoilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
    return Fahrenheit(c * 9/5 + 32)
}

func FToC(f Fahrenheit) Celsius {
    return Celsius((f - 32) * 5/9)
}
```

Creating distinct types helps distinguish to the developer that this should not be mixed with other floats. You then need to do explicit type conversions like `Celsius(t)` or `Fahrenheit(t)` to convert from a float64.

"A conversion never fails at run-time."

Because the underlying type of Celsius and Fahrenheit is float64, that means that Celsius and Fahrenheit are able to use all of the float64 arithmetic operators. But, just because the underlying type of Celsius and Fahrenheit is float64, that does not mean you can compare them to eachother:

```go
var c Celsius
var f Fahrenheit
fmt.Println(c == 0)          // true
fmt.Println(f >= 0)          // true
fmt.Println(c == f)          // compile error: type mismatch
fmt.Println(c == Celsius(f)) // true
```

When you declare your own types, you are also able to add whats called `methods` which give the type behaviors / extra functionality that do not exist by default.