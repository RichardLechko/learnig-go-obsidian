
"An array is a fixed-length sequence of zero or more elements of a particular type."

You use subscript notation to access an array:

```go
var a [3]int             // array of 3 integers that are all 0
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]

// Print the indices and elements.
for i, v := range a {
	fmt.Printf("%d %d\n", i, v)
}

// Print the elements only
for _, v := range a {
	fmt.Printf("%d\n", v)
}
```

This will print:

```txt
0
0
0 0
1 0
2 0
0
0
0
```

You can also initialize an array to have values:

```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2], q[0])
```

This will print out:

```txt
0 1
```

You can also skip specifying the length, like:

```go
z := [...]int{1, 2, 3}
fmt.Printf("%T\n", z)
```

This will print out:
```txt
[3]int
```

The size of the array determines the type of array, so a `[3]int` has a different type than `[4]int`. The size of the array must be determined at compile time.

You also have this:

```go
type Currency int

const (
	USD Currency = iota
	EUR
	GBP
	RMB
)

func main() {
	symbol := [...]string{USD: "Dollar", EUR: "Euro", GBP: "Pound", RMB: "Yuan"}
	fmt.Println(RMB, symbol[RMB])
}
```

Which will print out:
```txt
3 Yuan
```

You can also have this code:

```go
r := [...]int{99: -1}
fmt.Println(r)
```

Which will just create an array `r` with 100 elements all 0 except for the last one which is -1.

If the element that an array is holding is comparable then so is the array itself, so we can compare an array of ints to another array of ints:

```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c)
d := [3]int{1, 2}
fmt.Println(a == d) // compile error, can't compare [2] to [3], two different types
```

Besides the compiler error, this will print out:

```txt
true false false
```

Whenever you pass in an array to a function, that function receives a copy, meaning you are not actually changing the original array and if the array is large this can be very inefficient, so instead you should just pass in the pointer to the array:

```go
func zero(ptr *[32]byte) {
	for i := range ptr {
		ptr[i] = 0
	}
}
```

We pass in the pointer of this byte array as an argument, meaning the function is not receiving a copy of the array it's actually changing the original.

"Using a pointer to an array is efficient and allows the called function to mutate the caller's variable".