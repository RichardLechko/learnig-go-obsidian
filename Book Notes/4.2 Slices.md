
"Slices are variable-length sequences and all elements have the same type."

They are written like `[]T`.

A slice is a data structure that gives access to a subsequence (or all) of the elements of an array. There are three components that go into a slice:

- pointer, which points to the first element
- length, which is # of slice elements
- capacity, which is the # of elements from the start of the slice to the end of the underlying array

Slices contain a pointer to an element of an array, meaning if you pass a slice to a function, the function can modify the slice which in turn modifies the original array.

Here is the difference between initializing a slice and an array:

```go
a := [...]int{0, 1, 2, 3, 4, 5} // Array
s := []int{0, 1, 2, 3, 4, 5}    // Slice
```

The main difference is that you do not need to provide a size to create a slice since it's a dynamic data structure.

You can create a slice of an underlying array:

```go
// this is an array that has all months 1-12
months := [...]string{1: "January", 2: "February", 3: "March", 4: "April", 5: "May", 6: "June", 7: "July", 8: "August", 9: "September", 10: "October", 11: "November", 12: "December"}

// we then can create a slice of the underlying array and grab all months in Q2
Q2 := months[4:7]

// then we grab all months in summer
summer := months[6:9]
fmt.Println(Q2)
fmt.Println(summer)
```

This will print:

```txt
[April May June]
[June July August]
```

You can also see that we grabbed an overlapping element, June, and got no errors.

This will print out any months that are in Q2 and in Summer:

```go
for _, s := range summer {
	for _, q := range Q2 {
		if s == q {
			fmt.Printf("%s appears in both\n", s)
		}
	}
}
```

This will print:

```txt
June appears in both
```

Slicing outside of the range will throw an error: panic.

```go
// fmt.Println(summer[:20]) // This will result in an error
```

This will result in extending the slice to include more months:

```go
fmt.Println(summer[:5]) // [June July August September October]
```

You can see that even though we only passed in a slice, it still changed the underlying array:

```go
a := [...]int{0, 1, 2, 3, 4, 5}
reverse(a[:])
fmt.Println(a) // [5 4 3 2 1 0]
```

This function reverses a slice of ints in place:

```go
func reverse(s []int) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}
```

This rotates `s` left by two positions:

```go
s := []int{0, 1, 2, 3, 4, 5}
reverse(s[:2])
reverse(s[2:])
reverse(s)
fmt.Println(s)
```

Slices are not comparable, so you can not use something like `==` to compare two slices.

- If you have a `[]byte` slice, you can use `bytes.Equal`
- If it's not a `[]byte` slice, you need to do the comparison yourself:

```go
func equal(x, y []string) bool {
	if len(x) != len(y) {
		return false
	}
	for i := range x {
		if x[i] != y[i] {
			return false
		}
	}
	return true
}
```

- The only legal slice comparison is to compare it against nil to see if the slice is empty or not, but you should not do that. Use `len == 0` to see if a slice is empty.

"The zero value of a slice type is nil. A nil slice has no underlying array. The nil slice has length and capacity zero."

```go
var z []int    // len is 0 and z is nil
z = nil        // len is 0 and z is nil
z = []int(nil) // len is 0 and z is nil
z = []int{}    // len is 0 and z is not nil
```

### 4.2.2. In-Place Slice Techniques

This is an algorithm where given an array of strings return a slice a slice holding only the non-empty strings:

```go
func nonempty(strings []string) []string {
	i := 0
	for _, s := range strings {
		if s != "" {
			strings[i] = s
			i++
		}
	}
	return strings[:i]
}
```

The really cool part is that the input and output slice both point to the same underlying array, meaning at no point throughout this function do we copy or allocate memory for another array. This is the output:

```go
func main() {
	data := []string{"one", "", "three"}
	fmt.Printf("%q\n", nonempty(data))
	fmt.Printf("%q\n", data)
}
```

```txt
["one" "three"]
["one" "three" "three"]
```

You can also rewrite this using the `append` function:

```go
func nonempty2(strings []string) []string {
	out := strings[:0] // zero-length slice of underlying array
	for _, s := range strings {
		if s != "" {
			out = append(out, s)
		}
	}
	return out
}
```

Then this will produce this output:

```go
func main() {
	data := []string{"one", "", "three"}
	fmt.Printf("%q\n", nonempty2(data))
	fmt.Printf("%q\n", data)
}
```

```txt
["one" "three"]
["one" "three" "three"]
```

Both ways ensure that you are reusing the array and not copying one.

Using slices plus append also lets you implement a stack:

```go
stack := []int{}
stack = append(stack, 1)
stack = append(stack, 2)
stack = append(stack, 3)
stack = append(stack, 4)
stack = append(stack, 5)
stack = append(stack, 6)
stack = append(stack, 7)
stack = append(stack, 8)
stack = append(stack, 9)
```

First you make a stack:

```txt
[1 2 3 4 5 6 7 8 9]
```

Then if you want the top you do:

```go
top := stack[len(stack)-1]   // top of stack
stack = stack[:len(stack)-1] // pop, you are grabbing the slice from position 0 to len-1
fmt.Println(stack, top)
```

This will print:

```txt
[1 2 3 4 5 6 7 8] 9
```

Then this is how you remove an element, there are two main functions, one will preserve an order and one will not:

```go
func remove(slice []int, i int) []int {
	copy(slice[i:], slice[i+1:])
	return slice[:len(slice)-1]
}

func removeNoOrder(slice []int, i int) []int {
	slice[i] = slice[len(slice)-1]
	return slice[:len(slice)-1]
}
```

This will print out:

```txt
fmt.Println(remove(stack, 2))
fmt.Println(removeNoOrder(stack, 2))
```

```txt
[1 2 4 5 6 7 8]
[1 2 8 5 6 7 8]
```