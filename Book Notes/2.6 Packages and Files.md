← Previous: [[2.5 Type Declarations]] | → Next: [[2.7 Scope]]

## Purpose of Packages

Packages in Go support:

- **Modularity** - separating code into logical units
- **Encapsulation** - hiding implementation details
- **Separate compilation** - compiling packages independently
- **Reuse** - using packages across multiple programs

## Separate Name Spaces

Each package is a separate name space for its declarations. This means:

- You can have three functions with the same name in different packages
- They won't conflict because they're in different name spaces

## Visibility Control

Use [[Exported vs Unexported]] names to control visibility:

- **Title case** (e.g., `CToF`) → Exported (public)
- **Lowercase** (e.g., `helper`) → Unexported (private to package)

## Example: Temperature Conversion Package

### File: `tempconv/tempconv.go`

```go
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
    AbsoluteZeroC Celsius = -273.15
    FreezingC     Celsius = 0
    BoilingC      Celsius = 100
)

func (c Celsius) String() string {
    return fmt.Sprintf("%g°C", c)
}

func (f Fahrenheit) String() string {
    return fmt.Sprintf("%g°F", f)
}
```

### File: `tempconv/conv.go`

```go
package tempconv

func CToF(c Celsius) Fahrenheit {
    return Fahrenheit(c*9/5 + 32)
}

func FToC(f Fahrenheit) Celsius {
    return Celsius((f - 32) * 5/9)
}
```

## 2.6.1 Imports

### Setting Up a Module

Create a module using `go mod init`:

```bash
go mod init temperature
```

This creates a `go.mod` file in the root directory.

### Project Structure

```bash
.
├── cf
│   └── main.go   
├── go.mod
└── tempconv
    ├── conv.go
    └── tempconv.go
```

### Using the Package

File: `cf/main.go`

```go
package main

import (
    "fmt"
    "os"
    "strconv"
    "temperature/tempconv"
)

func main() {
    for _, arg := range os.Args[1:] {
        t, err := strconv.ParseFloat(arg, 64)
        if err != nil {
            fmt.Fprintf(os.Stderr, "cf: %v\n", err)
            os.Exit(1)
        }
        f := tempconv.Fahrenheit(t)
        c := tempconv.Celsius(t)
        fmt.Printf("%s = %s, %s = %s\n", 
            f, tempconv.FToC(f), c, tempconv.CToF(c))
    }
}
```

Notice how we use the package name as a prefix: `tempconv.CToF`, `tempconv.AbsoluteZeroC`

## Exercise 2.2 Solution

See: [[Exercise 2.2 - Unit Conversions]]

## 2.6.2 Package Initialization

### Initialization Order

[[Package-Level|Package-level]] variables are initialized:

1. In declaration order
2. After resolving dependencies

Example:

```go
var a = b + c  // initialized third (depends on b and c)
var b = f()    // initialized second (depends on f())
var c = 1      // initialized first (no dependencies)
```

### Multiple Files

If a package has multiple files:

- The Go compiler sorts files by name
- Then initializes variables across all files in dependency order

### The `init` Function

For complex initialization (like pre-computing lookup tables), use the `init` function:

```go
func init() {
    // initialization code
}
```

**Key facts about `init`:**

- Cannot be called or referenced
- Automatically executed when program starts
- Executed in order they're declared
- Can have multiple `init` functions in a package

### Example: Population Count Table

```go
package popcount

// pc[i] is the population count of i
var pc [256]byte

func init() {
    for i := range pc {
        pc[i] = pc[i/2] + byte(i&1)
    }
}

// PopCount returns the population count (number of set bits) of x
func PopCount(x uint64) int {
    return int(
        pc[byte(x>>(0*8))] +
        pc[byte(x>>(1*8))] +
        pc[byte(x>>(2*8))] +
        pc[byte(x>>(3*8))] +
        pc[byte(x>>(4*8))] +
        pc[byte(x>>(5*8))] +
        pc[byte(x>>(6*8))] +
        pc[byte(x>>(7*8))])
}
```

### Package Initialization Order

Packages are initialized in dependency order:

1. If package `p` imports package `q`, then `q` is fully initialized before `p` starts
2. All packages are initialized before `main` begins
3. The `main` package is initialized last

## Exercises

### Exercise 2.3

"Rewrite `PopCount` to use a loop instead of a single expression. Compare the performance of the two versions."

**Status:** ⚠️ Skipped - performance comparison requires Section 11.4

### Exercise 2.4

"Write a version of `PopCount` that counts bits by shifting its argument through 64 bit positions, testing the rightmost bit each time. Compare its performance to the table-lookup version."

**Status:** ⚠️ Skipped - performance comparison requires Section 11.4

### Exercise 2.5

"The expression `x&(x-1)` clears the rightmost non-zero bit of `x`. Write a version of `PopCount` that counts bits by using this fact, and assess its performance."

**Status:** ⚠️ Skipped - performance comparison requires Section 11.4

## Related Concepts

- [[Packages]]
- [[Modules]]
- [[go.mod]]
- [[Package Initialization]]
- [[init Function]]
- [[Import Paths]]
- [[Exported vs Unexported]]