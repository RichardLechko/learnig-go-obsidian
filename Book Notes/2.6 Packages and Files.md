Packages in Go is how the programming language supports modularity, encapsulation, separate compilation, and reuse. Each package is a separate name space for its declarations. Since its a separate name space, you can have three functions all have the same names but all be in different packages and still work on their own.

You can choose to make certain identifiers in your package public or not, if the identifier is title cased it'll be exported. As an example, this is in `tempconv.go`:

```go
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
    AbsoluteZeroC Celsius = -273.15
    FreezingC     Celsius = 0
    BoilingC      Celsius = 100
)

func (c Celsius) String() string {
    return fmt.Sprintf("%gC", c)
}

func (f Fahrenheit) String() string {
    return fmt.Sprintf("%gF", f)
}
```

Then this is `conv.go`:

```go
package tempconv

func CToF(c Celsius) Fahrenheit {
    return Fahrenheit(c * 9/5 + 32)
}

func FToC(f Fahrenheit) Celsius {
    return Celsius((f - 32) * 5/9)
}
```

So now we have a `tempconv` package. When that package is imported, all of the members have to start with `tempconv`, so like `tempconv.CToF`. Since the const variables are title cased, they can also be accessed anywhere if the package is imported, so like `tempconv.AbsoluteZeroC`.

### 2.6.1 Imports

Now that we have created the `tempconv` Go file with the types and then we have the `conv` Go file with the conversion logic, we run `go mod init temperature` to create a module named `temperature`, so this is our directory:

```bash
.
├── cf
│   ├── main.go   
├── go.mod
└── tempconv
    ├── conv.go
    └── tempconv.go
```

This `go.mod` lives in our root directory, so now this is the contents of `cf/main.go`:

```go
package main

import(
    "fmt"
    "os"
    "strconv"
    "temperature/tempconv"
)

func main() {
    for _, arg := range os.Args[1:] {
        t, err := strconv.ParseFloat(arg, 64)
        if err != nil {
            fmt.Fprintf(os.Stderr, "cf: %v\n", err)
            os.Exit(1)
        }
        f := tempconv.Fahrenheit(t)
        c := tempconv.Celsius(t)
        fmt.Printf("%s = %s, %s = %s\n", f, tempconv.FToC(f), c, tempconv.CToF(c))
    }
}
```

So you can see we are importing the `temperature` module into this `cf/main.go` file. 

### Exercise 2.2
"Write a general-purpose unit-conversion program analogous to `cf` that reads numbers from its command-line arguments or from the standard input if there are no arguments, and converts each number into units like temperature in Celsius and Fahrenheit, length in feet and meters, weight in pounds and kilograms, and the like."

This is my solution:

```bash
.
├── conversions
│   ├── go.mod
│   ├── lengthconv
│   │   ├── conv.go
│   │   └── lengthconv.go
│   ├── main
│   └── main.go
└── excercise-explanation.txt
```

In the `conversions/go.mod` we have:

```go
module conversions

go 1.22.2
```

We got this by running `go mod init conversions` so now our module is named `conversions`. This is the `conversions/lengthconv/conv.go`:

```go
// Package length conversion performs length conversions using the metric system
package lengthconversions

import "fmt"

type Millimeter float64
type Centimeter float64
type Meter      float64
type Kilometer  float64

func (mm Millimeter) String() string {
    return fmt.Sprintf("%gmm", mm)
}

func (cm Centimeter) String() string {
    return fmt.Sprintf("%gcm", cm)
}

func (m Meter) String() string {
    return fmt.Sprintf("%gm", m)
}

func (km Kilometer) String() string {
    return fmt.Sprintf("%gkm", km)
}
```

All this does is declare the four types of unit of measurements we will be covering and then declare String functions so we can print out these values. The types, Millimeter, Centimeter, and Meter are package-level declarations. 

This is the `conversions/lengthconv/lengthconv.go`:

```go
package lengthconversions

// Millimeters to Centimeters
func MMToCM(mm Millimeter) Centimeter {
    return Centimeter(mm / 10)
}

// Millimeters to Meters
func MMToM(mm Millimeter) Meter {
    return Meter( (MMToCM(mm)) / 100 )
}

// Millimeters to Kilometers
func MMToKM(mm Millimeter) Kilometer {
    return Kilometer( (MMToM(mm)) / 1000 )
}

// Centimeters to Millimeters
func CMToMM(cm Centimeter) Millimeter {
    return Millimeter(cm * 10)
}

// Centimeters to Meters
func CMToM(cm Centimeter) Meter {
    return Meter(cm / 100)
}

// Centimeters to Kilometers
func CMToKM(cm Centimeter) Kilometer {
    return Kilometer( (CMToM(cm)) / 1000 )
}

// Meters to Millimeters
func MToMM(m Meter) Millimeter {
    return Millimeter( MToCM(m) * 10)
}

// Meters to Centimeters
func MToCM(m Meter) Centimeter {
    return Centimeter(m * 100)
}

// Meters to Kilometers
func MToKM(m Meter) Kilometer {
    return Kilometer(m / 1000)
}

// Kilometers to Millimeters
func KMToMM(km Kilometer) Millimeter {
    return Millimeter( (KMToCM(km)) * 10 )
}

// Kilometers to Centimeters
func KMToCM(km Kilometer) Centimeter {
    return Centimeter( (KMToM(km) * 100) )
}

// Kilometers to Meters
func KMToM(km Kilometer) Meter {
    return Meter(km * 1000)
}
```

This is the code that converts measurements. Then, this is `conversions/main.go`:

```go
package main

import(
	"fmt"
	"os"
	"strconv"
	"conversions/lengthconv"
)

func main() {
	for _, arg := range os.Args[1:] {
		t, err := strconv.ParseFloat(arg, 64)
		if err != nil {
			fmt.Fprintf(os.Stderr, "cf: %v\n", err)
			os.Exit(1)
		}
		mm := lengthconversions.Millimeter(t)
		cm := lengthconversions.Centimeter(t)
		m  := lengthconversions.Meter(t)
		km := lengthconversions.Kilometer(t)
		fmt.Println("KILOMETER CONVERSION")
		fmt.Println("=================================================")
		fmt.Printf("KM: %s \t M: %s\n", km, lengthconversions.KMToM(km))
		fmt.Printf("KM: %s \t CM: %s\n", km, lengthconversions.KMToCM(km))
		fmt.Printf("KM: %s \t MM: %s\n", km, lengthconversions.KMToMM(km))
		fmt.Printf("=================================================\n\n")
		fmt.Println("METER CONVERSION")
		fmt.Println("=================================================")
		fmt.Printf("M: %s \t KM: %s\n", m, lengthconversions.MToKM(m))
		fmt.Printf("M: %s \t CM: %s\n", m, lengthconversions.MToCM(m))
		fmt.Printf("M: %s \t MM: %s\n", m, lengthconversions.MToMM(m))
		fmt.Printf("=================================================\n\n")
		fmt.Println("CENTIMETER CONVERSION")
		fmt.Println("=================================================")
		fmt.Printf("CM: %s \t KM: %s\n", cm, lengthconversions.CMToKM(cm))
		fmt.Printf("CM: %s \t M: %s\n", cm, lengthconversions.CMToM(cm))
		fmt.Printf("CM: %s \t MM: %s\n", cm, lengthconversions.CMToMM(cm))
		fmt.Printf("=================================================\n\n")
		fmt.Println("MILLIMETER CONVERSION")
		fmt.Println("=================================================")
		fmt.Printf("MM: %s \t KM: %s\n", mm, lengthconversions.MMToKM(mm))
		fmt.Printf("MM: %s \t M: %s\n", mm, lengthconversions.MMToM(mm))
		fmt.Printf("MM: %s \t CM: %s\n", mm, lengthconversions.MMToCM(mm))
		fmt.Printf("=================================================\n\n")
	}
}
```

When you run `go build main.go` and then run `./main 5` you get:

```txt
KILOMETER CONVERSION
=================================================
KM: 5km          M: 5000m
KM: 5km          CM: 500000cm
KM: 5km          MM: 5e+06mm
=================================================

METER CONVERSION
=================================================
M: 5m    KM: 0.005km
M: 5m    CM: 500cm
M: 5m    MM: 5000mm
=================================================

CENTIMETER CONVERSION
=================================================
CM: 5cm          KM: 5e-05km
CM: 5cm          M: 0.05m
CM: 5cm          MM: 50mm
=================================================

MILLIMETER CONVERSION
=================================================
MM: 5mm          KM: 5e-06km
MM: 5mm          M: 0.005m
MM: 5mm          CM: 0.5cm
=================================================
```

This properly completes the exercise.

### 2.6.2 Package Initialization 

As mentioned earlier in the prior exercise: Millimeter, Centimeter, and Meter are package-level declarations. The way this normally works is they are initialized in the order in which they are declared, but you first have to resolve any dependencies. In our code, there are no dependencies, but for example:

```go
var a = b + c // initialized third
var b = f()   // initialized second
var c = 1     // initialized first
```

If the package has multiple files, the Go compiler sorts the files by name.

There are also other ways to initialize variables, like if you have a table of data, it's better to just use the `func init` function mechanism:

```go
func init() { /* ... */ }
```

These can not be called or referenced and they are automatically executed when the program starts in the order which they are declared. You would often use `func init` for pre-computing a table of data.

One package is initialized at a time, same way as variables. If `p` is dependent on `q`, then `q` will be fully initialized before `p` starts. This process thus executes from bottom to top, with the main being last. All the packages are initialized before main gets executed.

Code Example:

```go
package popcount

// pc[i] is the population count of i.
var pc [256]byte

func init() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&1)
	}
}

// PopCount returns the population count (number of set bits) of x.
func PopCount(x uint64) int {
	return int(
		pc[byte(x>>(0*8))] +
		pc[byte(x>>(1*8))] +
		pc[byte(x>>(2*8))] +
		pc[byte(x>>(3*8))] +
		pc[byte(x>>(4*8))] +
		pc[byte(x>>(5*8))] +
		pc[byte(x>>(6*8))] +
		pc[byte(x>>(7*8))])
}
```

### Exercise 2.3

"Rewrite `PopCount` to use a loop instead of a single expression. Compare the performance of the two versions. (Section 11.4 shows how to compare the performance of different implementations systematically.)"

I have no clue how to assess performance, so I am skipping this.

### Exercise 2.4

"Write a version of `PopCount` that counts bits by shifting its argument through 64 bit positions, testing the rightmost bit each time. Compare its performance to the table-lookup version."

I have no clue how to assess performance, so I am skipping this.

### Exercise 2.5

"The expression `x&(x-1)` clears the rightmost non-zero bit of `x`. Write a version of `PopCount` that counts bits by using this fact, and assess its performance."

I have no clue how to assess performance, so I am skipping this.