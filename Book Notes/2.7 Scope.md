← Previous: [[2.6 Packages and Files]] | → Next: [[3.0 Basic Data Types]]

## Definition

A declaration associates a name with a program entity (like a variable or function). The **scope** of a declaration determines where in the source code that name can be referenced.

## Syntactic Blocks vs Lexical Blocks

### Syntactic Blocks

Explicitly surrounded by braces `{}`

```go
func main() {
    // This is a syntactic block
    var x = 1
}
```

### Lexical Blocks

Groups of declarations not explicitly surrounded by braces. Examples:

- Universe block (all Go source)
- Package block (all files in a package)
- File block (single file)
- Each `for`, `if`, `switch` statement creates its own lexical block

**Rule:** For each syntactic block, there is a corresponding lexical block.

## Scope vs Lifetime

**Critical Distinction:**

|Scope|Lifetime|
|---|---|
|Compile-time property|Run-time property|
|Where name can be referenced|How long variable exists|
|Static|Dynamic|

## Name Resolution

When the compiler encounters a variable reference, it searches for the declaration:

1. Innermost enclosing lexical block
2. If not found, next outer block
3. Continues until universe block
4. If still not found → `undeclared name` error

## Example: Multiple Declarations

```go
package main

import "fmt"

func main() {
    var a = 3
    fmt.Printf("Outside for loop: %d\n", a)
    
    for i := range 5 {
        var a = 1  // Different variable, shadows outer 'a'
        fmt.Println(a, i)
    }
}
```

**Output:**

```
Outside for loop: 3
1 0
1 1
1 2
1 3
1 4
```

The `for` loop creates its own syntactic block with its own scope. The inner `a` shadows the outer `a`.

## For Loop Scopes

A `for` loop creates **two** lexical blocks:

1. **Implicit block** for loop variables
2. **Explicit block** for the loop body

```go
func main() {
    x := "hello"
    for _, x := range x {      // x #2 (loop variable)
        x := x + 'A' - 'a'     // x #3 (body variable)
        fmt.Printf("%c", x)
    }
}
```

Three different variables named `x`:

1. `x := "hello"` - function body scope
2. `for _, x := range x` - loop variable scope
3. `x := x + 'A' - 'a'` - loop body scope

## Control Flow Statement Scopes

Variables declared in `if` statements are scoped to that statement:

```go
func main() {
    if 1 == 3 {
        x := 1
        y := 2
        fmt.Println(x, y)
    } else if 1 != 3 {
        a := 3
        b := 4
        fmt.Println(a, b)
    }
    fmt.Println(x, y, a, b)  // ✗ compile error!
}
```

Variables `x`, `y`, `a`, and `b` only exist within their respective `if` blocks.

### Nested If Blocks

To access variables from an outer `if` in an inner `if`:

```go
func main() {
    if 1 == 3 {
        x := 1
        y := 2
        fmt.Println(x, y)
        
        if 1 != 3 {
            a := 3
            b := 4
            fmt.Println(x, y, a, b)  // ✓ Can access x and y
        }
    }
}
```

## Common Pitfall: File Operations

**Incorrect:**

```go
func main() {
    if f, err := os.Open(fname); err != nil {
        return err
    }
    f.ReadByte()  // ✗ compile error: f not in scope
    f.Close()     // ✗ compile error: f not in scope
}
```

**Correct:**

```go
func main() {
    f, err := os.Open(fname)
    if err != nil {
        return err
    }
    f.ReadByte()  // ✓ f is in scope
    f.Close()     // ✓ f is in scope
}
```

## Short Variable Declaration Pitfall

Understanding scope is crucial when using `:=`:

**Incorrect:**

```go
var cwd string

func init() {
    cwd, err := os.Getwd()  // ✗ Creates new local cwd
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
    }
}
```

Problem: `cwd, err := os.Getwd()` declares a **new local** `cwd` that shadows the package-level `cwd`. The package-level `cwd` remains uninitialized.

**Correct:**

```go
var cwd string

func init() {
    var err error
    cwd, err = os.Getwd()  // ✓ Assigns to package-level cwd
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
    }
}
```

Solution: Declare `err` separately, then use `=` (assignment) instead of `:=` (declaration).

## Scope Levels Summary

From innermost to outermost:

1. **Block scope** - variables in `{}` blocks
2. **Loop scope** - loop variables
3. **Function scope** - function parameters and local variables
4. **Package scope** - package-level declarations
5. **File scope** - imported package names
6. **Universe scope** - built-in types and functions

## Related Concepts

- [[Lexical Blocks]]
- [[Syntactic Blocks]]
- [[Variable Shadowing]]
- [[Short Variable Declaration]]
- [[Lifetime vs Scope]]