
A declaration associates a name with a function or a variable (some sort of entity). The scope of the declaration just determines where in the source code the declared name can be used. Hence why you can have multiple variables named `i` but refer to different declarations.

If you have a block of code, wrapped in braces, a variable declared in that block of braces can not be referenced outside of it. The block of code determines its scope. Those are called `syntactic blocks`.

There are also `lexical blocks`. These are other groups of declarations that are not explicitly surrounded by braces. For each `syntactic block` there is a `lexical block`.

### Scope vs Lifetime

Scope is a compile-time property
Lifetime is a run-time property.

### Multiple Declarations

If there are multiple declarations of the same name of a variable, the compiler will look for the innermost enclosing lexical block. So if you have this code:

```go
package main

import "fmt"

func main() {

	var a = 3
	fmt.Printf("Outside for loop: %d\n", a)
	for i := range 5 {
		var a = 1
		fmt.Println(a, i)
	}
}
```

We have `a` declared twice, but that is because, as we mentioned earlier, the `for loop` is a program entity and thus is it's own `syntactic block` therefore it has its own scope. So when the compiler is inside of the `for loop` and it looks at the `var a`, it looks at the innermost lexical block which is the for loop. If it can't find `var a` for some reason, the compiler will move up and up until it hits the universal block. If the compiler can not find the variable you are referencing you will get a `undeclared name` error.

This code will print out:

```txt
Outside for loop: 3
1 0
1 1
1 2
1 3
1 4
```

You can see the compiler starts referencing the variable `a` that is inside the `for loop` and not the `var a` outside of the loop. Two lexical blocks are made in this for loop:

1. Explicit block for the body of the loop
2. Implicit block for the variables inside (i)

This is another code example:

```go
package main

import "fmt"

func main() {
	x := "hello"
	for _, x := range x {
		x := x + 'A' - 'a'
		fmt.Printf("%c", x)
	}
}
```

There are three variables named `x` and they are all in different blocks:

1. `x := "hello"` is inside the function body.
2. `for _, x := range x` declares `x` inside the `for` statement block.
3. `x := x + 'A' - 'a'` declares `x` inside the loop body.

#1 and #3 are explicit blocks and #2 is an implicit block.

Mentioned earlier, there are also scopes involved in control-flow statements:

```go
func main() {
	if 1 == 3 {
		x := 1
		y := 2
		fmt.Println(x, y)
	} else if 1 != 3 {
		a := 3
		b := 4
		fmt.Println(a, b)
	}
	fmt.Println(x, y, a, b)
}
```

As you can see, the variables `a`, `b`, `x`, and `y` are only declared inside of an `if` statement and thus the final print statement will throw a compile error. The variables x and y only exist in the first if statement and a and b only exist in the second if statement. You can't even pass x or y into the second if statement. If you wanted to, you would have to do something like:

```go
func main() {
	if 1 == 3 {
		x := 1
		y := 2
		fmt.Println(x, y)
		if 1 != 3 {
			a := 3
			b := 4
			fmt.Println(x, y, a, b)
		}
	}
	fmt.Println(x, y, a, b)
}
```

So now the second if statement can safely reference x and y. But the final print statement will still throw an error.

Another code example:

```go
func main() {
	if f, err := os.Open(fname); err != nil {
		return err
	}
	f.ReadByte()
	f.Close()
	
}
```

As you can see in here, variable `f` is declared in the if statement, and you will get compile errors when trying to run `f.ReadByte()` and `f.Close()` because you are trying to reference `f` outside of its scope.

To fix this you would do:

```go
func main() {
	f, err := os.Open(fname)
	if err != nil {
		return err
	}
	f.ReadByte()
	f.Close()
}
```

Now that `f` is declared outside the `if statement` it is now visible in the source code.

Since we know that the short variable declaration is used to initialize and declare variables, you have to understand how scope works in order to use `:=`, for example:

```go
package main

import (
	"os"
	"log"
)

var cwd string

func init() {
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("os.Getwd failed: %v", err)
	}
}
```

You will actually get a `unused variable` error when we write `cwd, err := os.Getwd()` because `cwd` is not being used anywhere. Since `cwd` and `err` are not declared when we enter the `init` function, they are declared as local variables from our short hand declaration. When we are inside of the `init` function, the `cwd` that gets declared now makes the innermost `cwd` inaccessible, which is not what we want. Right now `cwd` uninitialized, so we have to rewrite this to be:

```go
package main

import (
	"os"
	"log"
)

var cwd string

func init() {
	var err error
	cwd, err = os.Getwd()
	if err != nil {
		log.Fatalf("os.Getwd failed: %v", err)
	}
}
```

We have to remove the `:=` when we declare `cwd` in the `init` function.