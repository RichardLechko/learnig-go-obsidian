← Previous: [[2.3 Variables]] | → Next: [[2.5 Type Declarations]]

## Basic Assignment

The simplest form of assignment has a variable on the left of the equal sign and an expression on the right:

```go
x = 1                       // direct variable
*p = true                   // indirect variable
person.name = "bob"         // struct field
count[x] = count[x] * scale // array or slice or map element
```

## Compound Assignment Operators

Each arithmetic and bitwise binary operator has a corresponding assignment operator:

```go
count[x] *= scale  // same as: count[x] = count[x] * scale
```

### Increment and Decrement

You can use `++` and `--` shorthand to increment and decrement variables:

```go
v := 1  // v is equal to 1
v++     // same as v = v + 1; v becomes 2
v--     // same as v = v - 1; v becomes 1 again
```

**Important:** These are statements, not expressions:

- `j = i++` is **ILLEGAL**
- `j = --i` is **ILLEGAL**

## 2.4.1 Tuple Assignment

[[Tuple Assignment]] allows multiple variables to be assigned at once. All right-hand side expressions are evaluated first, then assignments are made.

```go
x, y = y, x              // swap x and y values
a[i], a[j] = a[j], a[i]  // swap array elements
```

**Best Practice:** Tuple assignments are useful but should not be used for complex situations. Sequential assignments are easier to read for complex operations.

### Functions Returning Multiple Values

If you call a function that returns two values, you need two variables on the left-hand side:

```go
f, err = os.Open("foo.txt") // function call returns two values
```

### The "ok" Idiom

Usually the second return value from a function is an error or boolean indicating success, often called `ok`:

```go
v, ok = m[key]  // map lookup
v, ok = x.(T)   // type assertion
v, ok = <-ch    // channel receive
```

### Discarding Values with Blank Identifier

You can discard unwanted values using the underscore `_` (blank identifier):

```go
_, err = io.Copy(dst, src)  // discard byte count
_, ok = x.(T)               // check type but discard result
```

## 2.4.2 Assignability

You can implicitly assign values when declaring variables:

```go
medals := []string{"gold", "silver", "bronze"}
```

The same implicit assignment works for [[Maps]] and [[Channels]].

### Type Compatibility Rules

- An assignment is legal if the variable and value have the same type
- You can assign `nil` to any variable of [[Interfaces|interface]] or [[Reference Types|reference type]]
- Constants have more flexible assignment rules (covered in [[Chapter 3]])

### Comparability

Two values can be compared with operators like `==` and `!=` only if:

- The first operand is assignable to the type of the second operand, **OR**
- The second operand is assignable to the type of the first operand

## Related Concepts

- [[Tuple Assignment]]
- [[Blank Identifier]]
- [[Assignment Operators]]
- [[Type Compatibility]]