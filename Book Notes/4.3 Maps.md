
The hash table is extremely important. It's a data structure, with an unordered collection of key/value pairs in which all keys are distinct and all values can be retrieved, updated, or removed using a constant number of key comparisons on the average, no matter how big the hash table is.

`map` is a reference to a `hash table`, and you write it like `map[K]V` where `K` is key and `V` is value.

All keys have to be the same type and all values have to be the same type, so you can have all keys be strings and all values be integers. Keys must be comparable.

There are a bunch of ways to initialize a map, these are two main ways to initialize an empty map:

```go
ages := map[string]int{}
ages := make(map[string]int)
```

Both of these maps will have strings mapped to integers and be empty.

If you want to use a map literal with some initial key/value pairs, you can do a short way and a long way:

```go
// short way
ages := map[string]int{
	"alice":   31,
	"charlie": 34,
}
```

```go
// long way
ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
```

Then if you want to access a element you use subscript notation, same as arrays and slices:

```go
ages := make(map[string]int)
ages["alice"] = 32
fmt.Println(ages["alice"])
```

This will print:

```txt
32
```

Then removing an element is just as easy:

```go
delete(ages, "alice")
fmt.Println(ages)
```

This will print out:

```txt
map[]
```

If you try an assign a key that does not exist in the map, that's ok, the key will by default have a value of zero for that type. So in a map of strings mapping to integers, if we try and access a string element that does not exist, the value will be 0, like:

```go
ages["bob"] = ages["bob"]
fmt.Println(ages["bob"])
ages["bob"] = ages["bob"] + 1
fmt.Println(ages["bob"])
```

This will print out:

```txt
0
1
```

You can also use the `x += y` and `x++` increments on maps:

```go
ages["bob"] += 1
fmt.Println(ages["bob"])
ages["bob"]++
fmt.Println(ages["bob"])
```

This will print out:

```txt
2
3
```

You are not allowed to take the address of a map element:

```go
_ = &ages["bob"] // compile error: cannot take address of map element
```

This is a basic loop enumerating all the key/value pairs:

```go
for name, age := range ages {
		fmt.Printf("%s\t%d\n", name, age)
}
```

This prints out:

```txt
bob     3
```

What if we were to add extra elements:

```go
ages["alice"] = 32
ages["charlie"] = 34
ages["tom"] = 60
ages["john"] = 44
```

Then printed them using the same loop:

```txt
bob     3
alice   32
charlie 34
tom     60
john    44
```

You can see that the keys are not ordered, this is intentional, and if you wanted to order them, you would use something like the `Strings` function from the `sort` package:

```go
var names []string
for name := range ages {
	names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
	fmt.Printf("%s\t%d\n", name, ages[name])
}
```

This will print out:

```txt
alice   32
bob     3
charlie 34
john    44
tom     60
```