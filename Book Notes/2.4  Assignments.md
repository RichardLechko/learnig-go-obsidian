Simplest way to assign a value to a variable is to have a variable on the left of the equal symbol and an expression on the right:

```go
x = 1                       // direct variable
*p = true                   // indirect variable
person.name = "bob"         // struct field
count[x] = count[x] * scale // array or slice or map element
```

Each bitwise binary and arithmetic operator has to have an assignment operator:

```go
count[x] *= scale
```

You can also use `--` and `++` shorthand to increment and decrement variables:

```go
v := 1 \\ v is equal to 1
v++    \\ same as v = v + 1; v becomes 2
v--    \\ same as v = v - 1; v becomes 1 again
```

### 2.4.1 Tuple Assignment

A tuple assignment lets multiple variables to be assigned at once. All right-hand side expressions are evaluated first.

```go
x, y = y, x // x and y swapped values
a[i], a[j] = a[j], a[i]
```

Tuple assignments are cool but do not do them for complex situations, since doing sequential expressions are easier to read.

If you call a function that returns two values, you need to have two variables on the left hand side:

```go
f, err = os.Open("foo.txt") // function call returns two values
```

Usually the 2nd return from a function is the error, also known as `ok`:

```go
v, ok = m[key] // map lookup
v, ok = x.(T)  // type assertion
v, ok = <-ch   // channel receive
```

For whatever reason they might fail, the value will be sent to `ok`. We can also discard the values we get back, by putting in an underscore to denote the compiler to discard the variable:

```go
_, err = io.Copy(dist, src) // discard byte count
_, ok = x.(T)               // check type but discard result
```

### 2.4.2 Assignability

You can also implicitly assign values:

```go
medals := []string{"gold", "silver", "bronze"}
```

You can do the same in maps and channels.

Any assignment is legal as long as the the variable and the value are the same type. And you can assign `nil` to any variable of interface or reference type.

You can only compare two variables with each other, using like `==` and `!=`, if the first operand is the same type as the second operand.